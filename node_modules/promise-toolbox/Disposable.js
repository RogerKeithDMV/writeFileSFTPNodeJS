"use strict";

var evalDisposable = require("./_evalDisposable");

var isDisposable = require("./_isDisposable");

var setFunctionNameAndLength = require("./_setFunctionNameAndLength");

var wrapCall = require("./wrapCall");

function Disposable(value, dispose) {
  if (typeof dispose !== "function") {
    throw new Error("dispose must be a function");
  }

  this.dispose = dispose;
  this.value = value;
}

module.exports = Disposable;

Disposable.all = function all(disposables) {
  var disposers = [];

  var dispose = function dispose() {
    var d = disposers;
    disposers = undefined;
    d.forEach(function (disposer) {
      return disposer();
    });
  };

  var onFulfill = function onFulfill(disposable) {
    if (disposers === undefined) {
      return isDisposable(disposable) && disposable.dispose();
    }

    if (isDisposable(disposable)) {
      disposers.push(disposable.dispose);
      return disposable.value;
    }

    return disposable;
  };

  var onReject = function onReject(error) {
    if (disposers === undefined) {
      return;
    }

    dispose();
    throw error;
  };

  return Promise.all(Array.from(disposables, function (disposable) {
    return evalDisposable(disposable).then(onFulfill, onReject);
  })).then(function (values) {
    return new Disposable(values, dispose);
  });
};

var ExitStack = require("./_ExitStack");

Disposable.factory = function (genFn) {
  return setFunctionNameAndLength(function () {
    var gen = genFn.apply(this, arguments);

    var _ExitStack = new ExitStack(),
        dispose = _ExitStack.dispose,
        stack = _ExitStack.value;

    var onEvalDisposable = function onEvalDisposable(value) {
      return isDisposable(value) ? loop(stack.enter(value)) : value;
    };

    var onFulfill = function onFulfill(_ref) {
      var value = _ref.value;
      return evalDisposable(value).then(onEvalDisposable);
    };

    var loop = function loop(value) {
      return wrapCall(gen.next, value, gen).then(onFulfill);
    };

    return loop().then(function (value) {
      return new Disposable(value, function () {
        return wrapCall(gen.return, undefined, gen).then(dispose);
      });
    }, function (error) {
      var forwardError = function forwardError() {
        throw error;
      };

      return dispose().then(forwardError, forwardError);
    });
  }, genFn.name, genFn.length);
};